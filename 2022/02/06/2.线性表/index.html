<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>线性表 | Hexo</title><script>var config = </script><script class="pjax-js">code.findCode();</script><script>window.onload = ()=>{var pjax = new Pjax({selectors:['title','article','#aside-block','.pjax-js']});};</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.0.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main class="right"><article><div id="post-bg"><div id="post-title"><h1>线性表</h1><div id="post-info"><span>First Post:<div style="display:inline-block;width:90px"><time datetime="2022-02-06T14:18:37.932Z" id="date"> 2022-02-06</time></div></span><br><span>Last Update:<div style="display:inline-block;width:90px"><time datetime="2022-02-06T14:52:38.053Z" id="updated"> 2022-02-06</time></div></span></div></div><hr><div id="post-content"><p>主要介绍了线性表的两种实现方式和基本操作</p>
<span id="more"></span>

<h2 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h2><p>线性表是逻辑结构中的线性结构，表示的是元素之间一对一的逻辑关系，这些元素的数据类型都相同。除开始元素外，每个元素都只有唯一后继元素；除结束元素外，每个元素都只有唯一前驱元素。</p>
<h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><p>我们用顺序存储来实现线性表，即用数组（存储结构）实现线性表，被称为顺序表，也可以叫”数组“（逻辑结构）。</p>
<h3 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h3><p>好处：存储密度高，可以随机访问，即可以通过下标访问，查找的时间复杂度为O(1)。</p>
<p>缺点：元素之间紧密相邻，插入和删除需要移动大量元素。</p>
<h3 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h3><h4 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h4><p>直接使用数组，由于数组的大小和空间已经确定，一旦空间占满，再加入新的数据就会产生溢出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50 <span class="hljs-comment">//定义顺序表的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> data[MaxSize]; <span class="hljs-comment">//存放数据的数组</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">//顺序表当前长度</span><br>&#125;SqList; <span class="hljs-comment">//顺序表的数据类型</span><br></code></pre></td></tr></table></figure>

<h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><p>在程序执行时，通过分配语句为数组申请空间，一旦空间占满，就再申请一块更大的空间替换原来的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> InitSize 100 <span class="hljs-comment">//定义顺序表初始长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> *data; <span class="hljs-comment">//指向存放数据数组首地址的指针</span><br>    <span class="hljs-type">int</span> MaxSize,length; <span class="hljs-comment">//顺序表最大长度和当前长度</span><br>&#125;SqList;<br><span class="hljs-comment">//动态分配语句</span><br><span class="hljs-comment">//C</span><br>L.data = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) *InintSize);<br><span class="hljs-comment">//C++</span><br>L.data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[InitSize];<br></code></pre></td></tr></table></figure>

<h3 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在顺序表L的第i个位置插入元素e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>) <span class="hljs-comment">//判断插入位置是否合法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(L.length &gt;= MaxSize) <span class="hljs-comment">//判断是否有储存空间</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = L.length; j &gt;= i; j--) <span class="hljs-comment">//将要插入位置及之后的元素后移</span><br>        L.data[j] = L.data[j - <span class="hljs-number">1</span>];<br>    L.data[i - <span class="hljs-number">1</span>] = e; <span class="hljs-comment">//插入元素</span><br>    L.length++; <span class="hljs-comment">//当前长度+1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//删除顺序表L第i个位置的元素，并将删除的元素返回</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length) <span class="hljs-comment">//判断删除位置是否合法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    e = L.data[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//记录删除的元素;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; L.length - <span class="hljs-number">1</span>; j++) <span class="hljs-comment">//将删除元素位置后的元素前移</span><br>        L.data[j - <span class="hljs-number">1</span>] = L.data[j]; <br>    L.length--; <span class="hljs-comment">//顺序表长度-1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//在顺序表L中查找元素e并返回下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span> e)</span></span>&#123; <span class="hljs-comment">//这里L没有使用取地址符&quot;&amp;&quot;是因为不需要改变顺序表</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; L.length; i++)<br>        <span class="hljs-keyword">if</span>(L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回下标</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//s</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><p>我们用链式存储来实现线性表，即用链表（存储结构）实现线性表，被称为“链表”（逻辑结构）。</p>
<h3 id="链表的特点"><a href="#链表的特点" class="headerlink" title="链表的特点"></a>链表的特点</h3><p>好处：不需要使用地址连续的存储单元，插入和删除不需要移动元素。</p>
<p>缺点：不能随机访问。</p>
<h3 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h3><p>链表的每个节点不但要储存数据，还要储存指向其后继的指针。</p>
<p>头指针：指向第一个节点的单独的指针。</p>
<p>头节点：一般链表的第一个节点不存放信息或记录表长等信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br>    <span class="hljs-type">int</span> data; <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next; <span class="hljs-comment">//指针域</span><br>&#125;LNode, *LinkList;<br></code></pre></td></tr></table></figure>

<p>注意：LNode是节点这个数据结构的名字，*LinkList是指向节点的指针，也就是节点的首地址。</p>
<h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="头插法建立链表"><a href="#头插法建立链表" class="headerlink" title="头插法建立链表"></a>头插法建立链表</h4><p>该方法从一个空表开始，将新节点插入表头，即头节点之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    LNode *s;<br>    <span class="hljs-type">int</span> x;<br>    L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode)); <span class="hljs-comment">//创建头节点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    cin &gt;&gt; x; <span class="hljs-comment">//输入节点个数</span><br>    <span class="hljs-keyword">while</span>(x--)&#123;<br>        s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode)); <span class="hljs-comment">//创建新节点</span><br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next; <span class="hljs-comment">//新节点指向第一个节点</span><br>        L-&gt;next = s; <span class="hljs-comment">//头节点指向新节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="尾插法建立链表"><a href="#尾插法建立链表" class="headerlink" title="尾插法建立链表"></a>尾插法建立链表</h4><p>该方法将新节点插入表尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LinkList <span class="hljs-title">List_TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    LNode *s,*r = L; <span class="hljs-comment">//r为尾指针，与头指针重合</span><br>    cin &gt;&gt; x;<br>    <span class="hljs-keyword">while</span>(x--)&#123;<br>        s = (LNode *)<span class="hljs-built_in">malooc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>        s-&gt;data = x;<br>        r-&gt;next = s; <span class="hljs-comment">//尾指针指向新节点</span><br>        r = s; <span class="hljs-comment">//尾指针后移</span><br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="按序号查找节点"><a href="#按序号查找节点" class="headerlink" title="按序号查找节点"></a>按序号查找节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> L;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="按值查找节点"><a href="#按值查找节点" class="headerlink" title="按值查找节点"></a>按值查找节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data != e)<br>        p = p-&gt;next;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>在链表L的第i个位置插入一个新节点，值为x</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//先调用按序号查找节点的方法，找到要插入位置前一个结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    LNode *s;<br>    s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode)); <span class="hljs-comment">//建立新结点</span><br>    LNode *p = <span class="hljs-built_in">GetElem</span>(L, i<span class="hljs-number">-1</span>); <span class="hljs-comment">//要插入位置前一个节点</span><br>    s-&gt;next = p-&gt;next; <span class="hljs-comment">//新节点指向后继结点</span><br>    p-&gt;next = s; <span class="hljs-comment">//前驱节点指向新节点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：后两句不能颠倒，因为p-&gt;next中是下一节点的首地址；如果颠倒，会找不到下一节点地址。</p>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除链表L第i个位置的节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//先调用按序号查找节点的方法，找到要删除位置前一个结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Delete</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    LNode *p, *q;<br>    p = <span class="hljs-built_in">GetElem</span>(L, i<span class="hljs-number">-1</span>); <span class="hljs-comment">//要删除位置前一个节点</span><br>    q = p-&gt;next; <span class="hljs-comment">//被删除节点</span><br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//前驱节点指向后继结点</span><br>    <span class="hljs-built_in">free</span>(q); <span class="hljs-comment">//释放空间</span><br>&#125;<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/02/06/1.%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/">数组和链表 Prev →</a></div></div></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details></div><div id="bottom-btn"><a id="to-top" onClick="index.scrolltop();" title="to top">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">John Doe</a></h1><div id="description"></div></div><div id="aside-block"><h1>INDEX</h1><div id="toc-div"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">什么是线性表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">线性表的顺序表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">顺序表的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">顺序表的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">2.2.1.</span> <span class="toc-text">静态分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">2.2.2.</span> <span class="toc-text">动态分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">顺序表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.1.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">2.3.3.</span> <span class="toc-text">按值查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.</span> <span class="toc-text">线性表的链式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">链表的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">链表的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">链表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">头插法建立链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">尾插法建立链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%BA%8F%E5%8F%B7%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.3.</span> <span class="toc-text">按序号查找节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.4.</span> <span class="toc-text">按值查找节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.5.</span> <span class="toc-text">插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.6.</span> <span class="toc-text">删除节点</span></a></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">2021 to 2022</span></nobr><br><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><br><text>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></text><text> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></text><wbr><text>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></text></footer></aside></main><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="//cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script></body></html>